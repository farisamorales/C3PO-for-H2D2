# native libraries
import os
import time
# third party libraries
import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
from scipy.optimize import OptimizeWarning
import matplotlib.pyplot as plt
# user defined libraries
import config_sed as conf_s
import config_temps as conf_t
from config_vars import *
from options_fits import *
from options_bounds import boundify


# Run this code in the main loop
def run_fits(starName):
    # Reset the fitting parameters results for each star. Only the results
    # which are generated by the code will be saved, then.
    (n1, n2, n3, n4, RW, RC, amin1, amin2, bos1, bos2, small_mass_warm,
        mass_warm, l_warm, l_warm_small) = [np.nan]*14

    # Grain compositions for each belt. Can change for different fits
    innerGrain = 'AstroSil'
    outerGrain = 'DirtyIceAstroSil'

    ############################################################################
    #                      READ IN STELLAR PROPERTIES
    ############################################################################
    # Read in the star file
    starData = conf_s.read_star_file(conf_s.STAR_FILES+'{}_stitched.txt'.format(
    # starData = conf_s.read_star_file(conf_s.STAR_FILES+'{}.txt'.format(
        starName))
    starT    = int(starData['TEMP'])
    starL    = starData[  'starL']
    specType = starData[ 'SpType']
    starD    = starData['DIST_pc']
    starM = starData[  'starM']
    # Fillers for in case the data is missing.
    starL    = [   starL, 1][   int(np.isnan(starL))]
    starM = [starM, 1][int(np.isnan(starM))]
    starD    = [   starD, 1][   int(np.isnan(starD))]

    ############################################################################
    #               HANDLE OBSERVED DATA / CONSTRUCT FITTING DATA
    ############################################################################
    # Sort Data according to SpitzerIRS vs all else
    allSpitz, nonSpitz = conf_s.sort_spitz_data(starData)
    allSpitz = conf_s.stitch_spitz(allSpitz)
    spitzWaves = allSpitz['wavelength']
    spitzFlux  = allSpitz[      'flux']
    spitzError = allSpitz[     'error']
    spitzInsts = allSpitz['instrument']
    '''Save all of the spitzer data that has been stitched and sorted into
    individual files for stacking/analysis. Run these next few lines to
    grab these data for all stars being run through this script.'''
    if spitzWaves.size and saveSpitzerData:
        spitzDF = pd.DataFrame(allSpitz)
        spitzDF.to_csv('Data/Spitzer/{}.txt'.format(starName), index=False)
        return
    elif saveSpitzerData:
        return

    # Sort Data according to AllWise/AllSky vs all else
    allSky, allWise, allData = conf_s.sort_wise_data(nonSpitz)

    # Choose either AllWise or AllSky, both, or neither
    if useAllWise and useAllSky:
        allWaves = nonSpitz['wavelength']
        allFlux  = nonSpitz['flux']
        allError = nonSpitz['error']
        allInsts = nonSpitz['instrument']
    elif useAllWise:
        allWaves = np.append(allData['wavelength'], allWise['wavelength'])
        allFlux  = np.append(allData['flux'], allWise['flux'])
        allError = np.append(allData['error'], allWise['error'])
        allInsts = np.append(allData['instrument'], allWise['instrument'])
    elif useAllSky:
        allWaves = np.append(allData['wavelength'], allSky['wavelength'])
        allFlux  = np.append(allData['flux'], allSky['flux'])
        allError = np.append(allData['error'], allSky['error'])
        allInsts = np.append(allData['instrument'], allSky['instrument'])
    else:
        allWaves = allData['wavelength']
        allFlux  = allData['flux']
        allError = allData['error']
        allInsts = allData['instrument']

    # Separate any UL data points for the fitting data points (3*sigma > signal)
    # Upper limits criterion 1
    idx      = np.where( (allFlux/allError) > 3 )
    fitWaves = allWaves[idx]; fitFlux  = allFlux[idx]
    fitError = allError[idx]; fitInsts = allInsts[idx]
    idx      = np.where( (allFlux/allError) <= 3 )
    ulWaves  = allWaves[idx]; ulFlux   = allFlux[idx] + 3*allError[idx]
    ulError  = allError[idx]; ulInsts  = allInsts[idx]
    # Remove any NaN data points (Simply missing data)
    idx      = np.isfinite(fitFlux)
    fitWaves = fitWaves[idx]; fitFlux  = fitFlux[idx]
    fitError = fitError[idx]; fitInsts = fitInsts[idx]
    # Remove any points with NaN for error
    # Upper Limits criterion 2
    idx      = np.isfinite(fitError)
    fitWaves = fitWaves[idx]; fitFlux  = fitFlux[idx]
    fitError = fitError[idx]; fitInsts = fitInsts[idx]
    # Put these points into the upper limit arrays
    idx      = np.isnan(allError)
    ulWaves  = np.append(ulWaves, allWaves[idx])
    ulFlux   = np.append(ulFlux, allFlux[idx])
    ulError  = np.append(ulError, allError[idx])
    ulInsts  = np.append(ulInsts, allInsts[idx])
    # Finally organize UL data into ascending order
    idx     = np.argsort(ulWaves)
    ulWaves = ulWaves[idx]; ulFlux  = ulFlux[idx]
    ulError = ulError[idx]; ulInsts = ulInsts[idx]
    # For plotting we don't want the UL data in totals
    allWaves = np.copy(fitWaves); allFlux  = np.copy(fitFlux)
    allError = np.copy(fitError); allInsts = np.copy(fitInsts)
    # Organize into ascending order by wavelength
    idx      = np.argsort(allWaves)
    allWaves = allWaves[idx]; allFlux  = allFlux[idx]
    allError = allError[idx]; allInsts = allInsts[idx]

    # Convolve SpitzerIRS to MIPS24 frf if possible
    if 'MIPS24' in starData['instrument'] and spitzInsts.size:
        # Convolve IRS data to the MIPS24 data
        idx = np.where(starData['instrument'] == 'MIPS24')
        MIPS24W = starData['wavelength'][idx]
        MIPS24F = starData['flux'][idx]
        mipsw, mipsr = np.loadtxt(conf_s.FILTERS_DIR + 'mips24_frf.txt',
            unpack=True)
        IRS24      = conf_s.convolve(mipsw, mipsr, spitzWaves, spitzFlux)
        spitzFlux *= (MIPS24F/IRS24)
        fitWaves   = np.append(fitWaves, spitzWaves)
        fitFlux    = np.append(fitFlux, spitzFlux)
        fitError   = np.append(fitError, spitzError)
    # Else, just add the spitzer data to fit data
    elif spitzInsts.size:
        fitWaves  = np.append(fitWaves, spitzWaves)
        fitFlux   = np.append(fitFlux, spitzFlux)
        fitError  = np.append(fitError, spitzError)

    # Organize fit data by increasing wavelength.
    idx = np.argsort(fitWaves)
    fitWaves = fitWaves[idx]
    fitFlux  = fitFlux[idx]
    fitError = fitError[idx]

    ############################################################################
    #                      LOAD AND NORMALIZE STELLAR MODEL
    ############################################################################
    # Load the stellar model
    ngWave, ngFnu, starLabel = conf_s.load_stellar_model(starT)
    # Normalize stellar model from either SL2 or 2MASSK data.
    if 'SpitzerIRS-SL2' in spitzInsts:
        idx          = np.where(np.logical_and(fitWaves>5, fitWaves<5.5))
        dataFluxNorm = np.nanmean(fitFlux[idx])
        ngFluxNorm   = np.nanmean(np.interp(fitWaves[idx], ngWave, ngFnu))
        n_3          = (dataFluxNorm/ngFluxNorm)
        ngFnu       *= n_3
    elif '2MASSK' in allInsts:
        # Find the 2MASSK data
        idx = np.where(starData['instrument'] == '2MASSK')
        if ( (starData['flux'][idx] * 0.25) < starData['error'][idx]
            and 'B_Tycho' in allInsts ):
            # IF 0.25FLUX < SIGMA for 2MASSK, then we use B_Tycho instead
            idx = np.where(starData['instrument'] == 'B_Tycho')
            # However, if we don't have B_Tycho, then we will still use 2MASSK
        dataFluxNorm = starData['flux'][idx]

        idx          = np.where(starData['instrument'] == '2MASSK')
        dataFluxNorm = starData['flux'][idx]
        ngFluxNorm   = np.exp(np.interp(np.log(starData['wavelength'][idx]),
            np.log(ngWave), np.log(ngFnu)))
        n_3          = (dataFluxNorm/ngFluxNorm)
        ngFnu       *= n_3
    # Interpolate the stellar model to the fitting data wavelengths
    ngFnu_fit = np.exp(np.interp(np.log(fitWaves), np.log(ngWave),
        np.log(ngFnu)))

    # Calculate luminosity of the star given the stellar model and star distance
    luminosity = conf_s.calc_luminosity(ngWave, ngFnu, starD)
    print( 'Calculated luminosity: {:0.3e}'.format(luminosity) )
    print( 'Given luminosity: {:0.3e}'.format(starL) )
    # grain temps calculator depends on having accurate luminosities
    starL = luminosity if (starL == 1) else starL

    # Load the grain temperatures, or calculate them
    grainTemps = dict()
    for grainComp in grainComps:
        try:
            if recalcTemps:
                raise ValueError
            grainTemps[grainComp] = np.load(
                conf_s.GRAIN_TEMPS_DIR+'{}_{}.npy'.format(starName, grainComp))
        except:
            print('calculating temperature for {}'.format(grainComp))
            grainTemps[grainComp] = conf_t.calc_temps(starT, starL, grainComp)
            np.save(
                conf_s.GRAIN_TEMPS_DIR+'{}_{}.npy'.format(starName, grainComp),
                grainTemps[grainComp], allow_pickle=False
                )
    if recalcTemps:
        return

    # Interpolate the emissivities to fitWaves
    emis = {}
    emis[innerGrain] = np.empty((conf_s.GRAINSIZES.size, fitWaves.size))
    for g in range(conf_s.GRAINSIZES.size):
        emis[innerGrain][g] = np.interp(fitWaves, conf_s.WAVELENGTHS,
            conf_s.EMISSIVITIES_TOTAL[innerGrain][g])
    emis[outerGrain] = np.empty((conf_s.GRAINSIZES.size, fitWaves.size))
    for g in range(conf_s.GRAINSIZES.size):
        emis[outerGrain][g] = np.interp(fitWaves, conf_s.WAVELENGTHS,
            conf_s.EMISSIVITIES_TOTAL[outerGrain][g])

    # create the star object. both low and high resolution
    star = conf_s.Star(starName, starD, starL, starT, starM, grainTemps, emis,
        fitWaves)

    # Pull the blowoutsize
    star.bos1 *= bosScalar1; star.bos2 *= bosScalar2
    bos1 = star.bos1; bos2 = star.bos2

    # Grab the minimum radial location that's below the temp
    # of sublimation for volatiles. (Icy belt radius)
    for r in range(conf_s.TEMPS_RADII.size):
        # If mean temp < 120, then that becomes the min radius
        if np.nanmean(grainTemps[outerGrain][r]) < 120:
            break
    minRad = conf_s.TEMPS_RADII[r]

    print( '----------------------------------------' )
    print( '      AS blowout size: {:.2e}'.format(bos1) )
    print( '     IMP blowout size: {:.2e}'.format(bos2) )
    print( ' Minimum radius for an icy belt: {:.2f}'.format(minRad) )

    # Warm r0 guess is half the distance between the cold belt min & the star
    bbr1 = minRad*0.5
    # Cold belt guess is either from spatially resolved radii or 1.5*minRad
    if useSpatialRadii:
        rData = pd.read_csv('./Data/spatialRadii.csv', index_col=False)
        for i in range(len(rData)):
            if starName in [ rData.at[i, 'name'], rData.at[i, 'hip_name'] ]:
                bbr2     = rData.at[i, 'r']
                bbr2_unc = rData.at[i, 'r_sig']
                try:
                    if 3*bbr2_unc > bbr2 or np.isnan(bbr2):
                        raise ValueError('No valid radius from Herschel')
                    sTrigger = 1
                except:
                    bbr2 = minRad*1.5
                    sTrigger = 0
                break
        else:
            bbr2 = minRad*1.5
            sTrigger = 0
    else:
        bbr2 = minRad*1.5
        sTrigger = 0

    if bbr2 > 1000:
        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        print('The initial guess for the cold belt {} is greater'.format(bbr2))
        print('than the highest possible value of 1000. Continuing with next')
        print('star. In future, we may expand radial locations?')
        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        return

    print( 'initial guess for RW: {:.2f}'.format(bbr1) )
    print( 'initial guess for RC: {:.2f}'.format(bbr2) )

    # Normalize warm and cold dust
    # Set initial guess for the blowout size. If the bounded region includes the
    # calculated blowout size, use that, else go in between the bounds.
    if amin1_Low >= 1 or amin1_High <= 1:
        p0amin1 = bos1*np.average([amin1_High, amin1_Low])
    else:
        p0amin1 = bos1
    if amin2_Low >= 1 or amin2_High <= 1:
        p0amin2 = bos2*np.average([amin2_High, amin2_Low])
    else:
        p0amin2 = bos2
    if oneWander:
        bb1 = star.low_res_warm_amin(fitWaves, bbr1, p0amin1)
        bb2 = star.low_res_cold(fitWaves, bbr2)
    elif twoWander:
        bb1 = star.low_res_warm_amin(fitWaves, bbr1, p0amin1)
        bb2 = star.low_res_cold_amin(fitWaves, bbr2, p0amin2)
    elif noWander:
        bb1 = star.low_res_warm(fitWaves, bbr1)
        bb2 = star.low_res_cold(fitWaves, bbr2)
    elif twoWarmBelts:
        bb1 = star.low_res_warm(fitWaves, bbr1)
        bb2 = star.low_res_cold(fitWaves, bbr2)
    elif oneBeltWander:
        bb2 = star.low_res_cold_amin(fitWaves, bbr2, p0amin2)

    # warm
    if not oneBeltWander:
        n_1 = fitFlux[fitFlux>0].min() / bb1.max() # new test
    # cold
    n_2 = fitFlux[fitWaves>=70].mean() / bb2.max()
    # Reset norm factor for ngfNu
    n_3 = 1

    if showNormedBelts:
        # Show the normalized belts with observed flux and stellar model
        fig = plt.figure(figsize=(8, 6))
        plt.plot(ngWave, ngFnu, label='Stellar Model', color='g')
        plt.plot(fitWaves, n_1*bb1, label='Warm Belt')
        plt.plot(fitWaves, n_2*bb2, label='Cold Belt')
        plt.scatter(fitWaves, fitFlux, label='Observed Data')
        plt.xlim(1, 300)
        plt.ylim(n_1*bb1.max()*0.1, n_2*bb2.max()*100 )
        plt.title(starName+': for seeing the normalized belts', fontsize=22)
        plt.legend()
        plt.xlabel(r'$\lambda$ ($\mu m$)')
        plt.ylabel(r'$F_{\nu}$ ($Jy$)')
        plt.semilogx()
        plt.semilogy()
        plt.show()
        return


    ############################################################################
    #                      Single Belt fitting functions
    ############################################################################
    # oneBelt
    def oneColdBelt(waves, r0cold, n2, n3):
        '''One cold belt with a_min == calculated blowout size'''
        return n2*star.low_res_cold(waves, r0cold) + n3*ngFnu_fit

    # oneBeltWander
    def oneColdWander(waves, r0cold, n2, n3, amin2):
        '''One cold belt with wandering a_min'''
        return n2*star.low_res_cold_amin(waves, r0cold, amin2) + n3*ngFnu_fit

    ############################################################################
    #                      Two Belt fitting functions
    ############################################################################
    # Fitting functions for optimization routine
    # option: noWander
    def warmCold(waves, r0warm, r0cold, n1, n2, n3):
        ''' Standard realistic grain fit: one warm belt, one cold belt '''
        return n1*star.low_res_warm(waves, r0warm) \
            + n2*star.low_res_cold(waves, r0cold) + n3*ngFnu_fit
    # option: oneWander
    def oneWarmWander(waves, r0warm, r0cold, amin1, n1, n2, n3):
        ''' one warm belt with a wandering blowout grain size, one cold belt '''
        return n1*star.low_res_warm_amin(waves, r0warm, amin1) \
            + n2*star.low_res_cold(waves, r0cold) + n3*ngFnu_fit
    # option: twoWander
    def warmColdWander(waves, r0warm, r0cold, amin1, amin2, n1, n2, n3):
        ''' one warm belt with a wandering blowout grain size,
        one cold belt with a wandering blowout grain size'''
        return n1*star.low_res_warm_amin(waves, r0warm, amin1) \
            + n2*star.low_res_cold_amin(waves, r0cold, amin2) + n3*ngFnu_fit
    # option: twoWarmBelts
    def twoWarmCold(waves, r0warm, r0cold, amin1, n1, n2, n3, n4):
        return n1*star.low_res_warm(waves, r0warm) \
            + n2*star.low_res_cold(waves, r0cold) + n3*ngFnu_fit \
            + n4*star.low_res_warm_small(waves, r0warm, amin1)


    ############################################################################
    #                  Initialize the bounds of the routine
    ############################################################################
    # Run the optimization routine
    print('----------------------------------------')
    print( '      Begin Optimizing Parameters' )
    print('----------------------------------------')
    rw = bbr1
    rc = bbr2

    if oneWander:
        # parameters: r0warm, r0cold, amin1, n1, n2, n3
        if useSpatialRadii and sTrigger:
            lBounds = [0.3, bbr2-bbr2_unc, amin1_Low*bos1,
                    n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, bbr2+bbr2_unc, amin1_High*bos1,
                    n_1*beltBound, n_2*beltBound, n_3*1.2]
        else:
            lBounds = [0.3, minRad, amin1_Low*bos1, n_1/beltBound,
                n_2/beltBound, n_3*0.8]
            uBounds = [minRad, maxRad, amin1_High*bos1,
                n_1*beltBound, n_2*beltBound, n_3*1.2]
        p0=(rw, rc, p0amin1, n_1, n_2, n_3)
    elif twoWander:
        # parameters: r0warm, r0cold, amin1, amin2, n1, n2, n3
        if useSpatialRadii and sTrigger:
            lBounds = [0.3, bbr2 - 2*bbr2_unc, bos1*amin1_Low,
                bos2*amin2_Low, n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, bbr2 + 2*bbr2_unc, bos1*amin1_High,
                bos2*amin2_High, n_1*beltBound, n_2*beltBound, n_3*1.2]
        else:
            lBounds = [0.3, minRad, bos1*amin1_Low, bos2*amin2_Low,
                    n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, maxRad, bos1*amin1_High, bos2*amin2_High,
                    n_1*beltBound, n_2*beltBound, n_3*1.2]
        p0=(rw, rc, p0amin1, p0amin2, n_1, n_2, n_3)
    elif noWander:
        # parameters: r0warm, r0cold, n1, n2, n3
        if useSpatialRadii and sTrigger:
            lBounds = [0.3, bbr2-bbr2_unc, n_1/beltBound, n_2/beltBound,
                n_3*0.8]
            uBounds = [minRad, bbr2+bbr2_unc, n_1*beltBound, n_2*beltBound,
                n_3*1.2]
        else:
            lBounds = [0.3, minRad, n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, maxRad, n_1*beltBound, n_2*beltBound, n_3*1.2]
        p0=(rw, rc, n_1, n_2, n_3)
    elif twoWarmBelts:
        # params: r0warm, r0cold, amin1, n1, n2, n3, n4
        if useSpatialRadii and sTrigger:
            lBounds = [0.3, bbr2-bbr2_unc, amin1_Low*bos1, n_1/beltBound,
                n_2/beltBound, n_3*0.8, n_1/beltBound]
            uBounds = [minRad, bbr2+bbr2_unc, bos1, n_1*beltBound,
                n_2*beltBound, n_3*1.2, n_1*beltBound]
        else:
            lBounds = [0.3, minRad, amin1_Low*bos1, n_1/beltBound,
                n_2/beltBound, n_3*0.8, n_1/beltBound]
            uBounds = [minRad, maxRad, bos1, n_1*beltBound, n_2*beltBound,
                n_3*1.2, n_1*beltBound]
        p0=(rw, rc, bos1/2, n_1, n_2, n_3, n_1)
    elif oneBeltWander:
        # params: r0cold, amin2, n2, n3
        if useSpatialRadii and sTrigger:
            lBounds = [bbr2-bbr2_unc,  amin2_Low*bos2, n_2/beltBound, n_3*0.8]
            uBounds = [bbr2+bbr2_unc, amin2_High*bos2, n_2*beltBound, n_3*1.2]
        else:
            lBounds = [minRad,  amin2_Low*bos2, n_2/beltBound, n_3*0.8]
            uBounds = [maxRad, amin2_High*bos2, n_2*beltBound, n_3*1.2]
        p0=(rc, p0amin2, n_2, n_3)
    bounds=[lBounds, uBounds]


    ############################################################################
    #                      Call optimization routine
    ############################################################################
    # Timer for the routine
    before = time.perf_counter()
    # Call the optimization routine here.
    try:
        if oneWander:
            popt, pcov = curve_fit(oneWarmWander, fitWaves, fitFlux,
                sigma=fitError, p0=p0, bounds=bounds)
        elif twoWander:
            popt, pcov = curve_fit(warmColdWander, fitWaves, fitFlux,
                sigma=fitError, p0=p0, bounds=bounds)
        elif noWander:
            popt, pcov = curve_fit(warmCold, fitWaves, fitFlux, sigma=fitError,
                p0=p0, bounds=bounds)
        elif twoWarmBelts:
            popt, pcov = curve_fit(twoWarmCold, fitWaves, fitFlux,
                sigma=fitError, p0=p0, bounds=bounds)
        elif oneBeltWander:
            popt, pcov = curve_fit(oneColdWander, fitWaves, fitFlux,
                sigma=fitError, p0=p0, bounds=bounds)
    except RuntimeError:
        print('RuntimeError: The least squares minimization failed.')
        print('Continuing with next star')
        return
    except ValueError:
        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        print('ValueError: Potentially xdata or ydata contains NaN')
        print('Check flux sigma for nan values.')
        print('Use those points as UL data instead.')
        print('Continuing with next star')
        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        return
    except OptimizeWarning:
        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        print('The covariance of the parameters cannot be estimated')
        print('Continuing with next star')
        print('!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!')
        return
    # Timer for the fitting routine
    after = time.perf_counter()
    # Unpack the parameters and print them to the terminal for the user
    if oneWander:
        RW, RC, amin1, n1, n2, n3 = popt
    elif twoWander:
        RW, RC, amin1, amin2, n1, n2, n3 = popt
    elif noWander:
        RW, RC, n1, n2, n3 = popt
    elif twoWarmBelts:
        RW, RC, amin1, n1, n2, n3, n4 = popt
    elif oneBeltWander:
        RC, amin2, n2, n3 = popt
    print( '  Time to optimize parameters: {:.2f}s'.format(after-before) )
    if not oneBeltWander:
        print( '        Warm radius: {:.2f}'.format(RW) )
    print( '        Cold radius: {:.2f}'.format(RC) )
    if not oneBeltWander:
        print( '          Warm norm: {:.2e}'.format(n1) )
    print( '          Cold norm: {:.2e}'.format(n2) )
    print( '       Stellar norm: {:.2f}'.format(n3) )
    if oneWander:
        print( ' Warm min grainsize: {:.2f}'.format(amin1) )
    elif twoWander:
        print( ' Warm min grainsize: {:.2f}'.format(amin1))
        print( ' Cold min grainsize: {:.2f}'.format(amin2))
    elif noWander:
        pass
    elif twoWarmBelts:
        print( '  Minimum Grainsize: {:.2f}'.format(amin1) )
    elif oneBeltWander:
        print( '  Minimum Grainsize: {:.2f}'.format(amin2) )
    print( '----------------------------------------' )

    # Calculate reduced chi square value
    if oneWander:
        resid = fitFlux-oneWarmWander(fitWaves, RW, RC, amin1, n1, n2, n3)
        degsFreedom = fitWaves.size - 6 # ^ number of fit params ^
    elif twoWander:
        resid = fitFlux-warmColdWander(fitWaves,RW,RC,amin1,amin2,n1,n2,n3)
        degsFreedom = fitWaves.size - 7 # ^ number of fit params ^
    elif noWander:
        resid = fitFlux-warmCold(fitWaves, RW, RC, n1, n2, n3)
        degsFreedom = fitWaves.size - 5 # ^ number of fit params ^
    elif twoWarmBelts:
        resid = fitFlux-twoWarmCold(fitWaves, RW, RC, amin1, n1, n2, n3, n4)
        degsFreedom = fitWaves.size - 7 # ^ number of fit params ^
    elif oneBeltWander:
        resid = fitFlux-oneColdWander(fitWaves, RC, amin2, n2, n3)
        degsFreedom = fitWaves.size - 4 # ^ number of fit params ^
    resid /= fitError
    chiSqr = np.dot(resid, resid)/degsFreedom # Reduced chi square

    # Begin plotting routine
    if showIRSVariance:
        # Create a figure with two plots, one for the model + data, one for the
        # IRS variance
        fig = plt.figure(figsize=(8, 10))
        ax = fig.add_subplot(211)
    else:
        # Otherwise just create a figure with a single plot for the model + data
        fig = plt.figure(figsize=(8, 6))
        ax = fig.add_subplot(111)

    # Calculate the high resolution totalFlux array given the optimized
    # parameters
    if oneWander:
        y1 = n1 * star.high_res_warm_amin(conf_s.WAVELENGTHS, RW, amin1)
        y2 = n2 * star.high_res_cold(conf_s.WAVELENGTHS, RC)
        ngModel = np.e**np.interp(np.log(conf_s.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y1 + y2 + ngModel
        np.savetxt(conf_s.FARRAYS_DIR+'Warm Wander/{}.txt'.format(starName),
            np.column_stack((conf_s.WAVELENGTHS, y1, y2, ngModel, totalFlux)),
            header='waves\twarm\tcold\tstellarmodel\ttotalflux')
    elif twoWander:
        y1 = n1 * star.high_res_warm_amin(conf_s.WAVELENGTHS, RW, amin1)
        y2 = n2 * star.high_res_cold_amin(conf_s.WAVELENGTHS, RC, amin2)
        ngModel = np.e**np.interp(np.log(conf_s.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y1 + y2 + ngModel
        # I want to save the spitzer data and the idealized models at the
        # spitzer wavelengths so that I can do the stacking
        # First, interpolate each model to the spitzer waves
        if spitzWaves.size and stackSave:
            near_amin = conf_s.find_nearest(conf_s.GRAINSIZES, amin1)
            near_bos  = conf_s.find_nearest(conf_s.GRAINSIZES, bos1)
            if near_amin < near_bos:
                medium_warm_flux = star.high_res_warm_amin(conf_s.WAVELENGTHS,
                    RW, bos1) * n1
                small_warm_flux = star.high_res_warm_small(conf_s.WAVELENGTHS,
                    RW, amin1) * n1
                medium_warm_ideal = np.exp(np.interp(
                    np.log(spitzWaves), np.log(conf_s.WAVELENGTHS),
                    np.log(medium_warm_flux)
                    ))
                small_warm_ideal = np.exp(np.interp(
                    np.log(spitzWaves), np.log(conf_s.WAVELENGTHS),
                    np.log(small_warm_flux)
                    ))
            else:
                medium_warm_ideal = [np.nan]*spitzWaves.size
                small_warm_ideal = [np.nan]*spitzWaves.size
            warm_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(y1)
                ))
            cold_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(y2)
                ))
            star_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(ngModel)
                ))
            stacking_d = {'wavelength': spitzWaves, 'flux': spitzFlux,
                'error': spitzError, 'instrument': spitzInsts,
                'warm_ideal': warm_ideal, 'cold_ideal': cold_ideal,
                'star_ideal': star_ideal, 'med_warm_ideal': medium_warm_ideal,
                'small_warm_ideal': small_warm_ideal}
            stacking_df = pd.DataFrame(stacking_d)
            stacking_df.to_csv(
                conf_s.FARRAYS_DIR+'Both Wander/{}.csv'.format(starName),
                index=False
                )

    elif noWander:
        y1 = n1 * star.high_res_warm(conf_s.WAVELENGTHS, RW)
        y2 = n2 * star.high_res_cold(conf_s.WAVELENGTHS, RC)
        ngModel = np.e**np.interp(np.log(conf_s.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y1 + y2 + ngModel
        if spitzWaves.size and stackSave:
            warm_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(y1)
                ))
            cold_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(y2)
                ))
            star_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(ngModel)
                ))
            stacking_d = {'wavelength': spitzWaves, 'flux': spitzFlux,
                'error': spitzError, 'instrument': spitzInsts,
                'warm_ideal': warm_ideal, 'cold_ideal': cold_ideal,
                'star_ideal': star_ideal}
            stacking_df = pd.DataFrame(stacking_d)
            stacking_df.to_csv(
                conf_s.FARRAYS_DIR+'Both Wander/{}.csv'.format(starName),
                index=False
                )
    elif twoWarmBelts:
        y1 = n1 * star.high_res_warm(conf_s.WAVELENGTHS, RW)
        y2 = n2 * star.high_res_cold(conf_s.WAVELENGTHS, RC)
        y3 = n4 * star.high_res_warm_small(conf_s.WAVELENGTHS, RW, amin1)
        ngModel = np.e**np.interp(np.log(conf_s.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y1 + y2 + y3 + ngModel
        if spitzWaves.size and stackSave:
            warm_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(y1)
                ))
            small_warm_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(y3)
                ))
            cold_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(y2)
                ))
            star_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(ngModel)
                ))
            stacking_d = {'wavelength': spitzWaves, 'flux': spitzFlux,
                'error': spitzError, 'instrument': spitzInsts,
                'warm_ideal': warm_ideal, 'small_warm_ideal': small_warm_ideal,
                'cold_ideal': cold_ideal, 'star_ideal': star_ideal}
            stacking_df = pd.DataFrame(stacking_d)
            stacking_df.to_csv(
                conf_s.FARRAYS_DIR+'Both Wander/{}.csv'.format(starName),
                index=False
                )
    elif oneBeltWander:
        y2 = n2 * star.high_res_cold_amin(conf_s.WAVELENGTHS, RC, amin2)
        ngModel = np.e**np.interp(np.log(conf_s.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y2 + ngModel
        # I want to save the spitzer data and the idealized models at the
        # spitzer wavelengths so that I can do the stacking
        # First, interpolate each model to the spitzer waves
        if spitzWaves.size and stackSave:
            cold_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(y2)
                ))
            star_ideal = np.exp(np.interp(
                np.log(spitzWaves), np.log(conf_s.WAVELENGTHS), np.log(ngModel)
                ))
            stacking_d = {'wavelength': spitzWaves, 'flux': spitzFlux,
                'error': spitzError, 'instrument': spitzInsts,
                'cold_ideal': cold_ideal, 'star_ideal': star_ideal}
            stacking_df = pd.DataFrame(stacking_d)
            stacking_df.to_csv(
                conf_s.FARRAYS_DIR+'One Cold Wander/{}.csv'.format(starName),
                index=False
                )

    # Calculate Lstar/Ldust
    if not oneBeltWander:
        l_warm = conf_s.lum_ratio(ngModel, y1, conf_s.WAVELENGTHS)
    l_cold = conf_s.lum_ratio(ngModel, y2, conf_s.WAVELENGTHS)
    if twoWarmBelts:
        l_warm_small = conf_s.lum_ratio(ngModel, y3, conf_s.WAVELENGTHS)

    # Calculate dust mass of each belt in lunar masses
    if oneWander:
        mass_warm = star.calcDustMass(n1, RW, amin1*1e-6, 1e-3,
            densities[innerGrain])/moon_mass
        mass_cold = star.calcDustMass(n2, RC, bos2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
    elif twoWander:
        mass_warm = star.calcDustMass(n1, RW, amin1*1e-6, 1e-3,
            densities[innerGrain])/moon_mass
        mass_cold = star.calcDustMass(n2, RC, amin2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
    elif noWander:
        mass_warm = star.calcDustMass(n1, RC, bos1*1e-6, 1e-3,
            densities[innerGrain])/moon_mass
        mass_cold = star.calcDustMass(n2, RC, bos2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
    elif twoWarmBelts:
        mass_warm = star.calcDustMass(n1, RW, bos1*1e-6, 1e-3,
            densities[innerGrain])/moon_mass
        mass_cold = star.calcDustMass(n2, RC, bos2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
        small_mass_warm = star.calcDustMass(n1, RW, amin1*1e-6,
            bos1*1e-6, densities[innerGrain])/moon_mass
    elif oneBeltWander:
        mass_cold = star.calcDustMass(n1, RC, amin2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
    if showDustMass:
        if not oneBeltWander:
            print('Warm dust mass: {:.2e} lunar masses'.format(
                mass_warm))
        print('Cold dust mass: {:.2e} lunar masses'.format(
            mass_cold))
        if twoWarmBelts:
            print('Warm small grain dust mass: {:.2e} lunar masses'.format(
                small_mass_warm))

    if showLumRatios:
        if not oneBeltWander:
            print('Ldust_warm/Lstar: {:.2e}'.format(l_warm))
        print('Ldust_cold/Lstar: {:.2e}'.format(l_cold))
        if twoWarmBelts:
            print('Ldust_warm_small_grains/Lstar: {:.2e}'.format(l_warm_small))

    # Calculate the flux ratios
    if twoWarmBelts:
        (fh70warm, fh70cold, fh100warm, fh100cold, fh160warm, fh160cold,
            fh70warmsmall, fh100warmsmall, fh160warmsmall
            ) = conf_s.flux_ratios_herschel(y1=y1, y2=y2, ngModel=ngModel, y3=y3)
        (fm24warm, fm24cold, fm70warm, fm70cold, fm160warm, fm160cold,
            fm24warmsmall, fm70warmsmall, fm160warmsmall
            ) = conf_s.flux_ratios_mips(y1=y1, y2=y2, ngModel=ngModel, y3=y3)

    elif not oneBeltWander:
        (fh70warm, fh70cold, fh100warm, fh100cold, fh160warm, fh160cold,
            fh70warmsmall, fh100warmsmall, fh160warmsmall
            ) = conf_s.flux_ratios_herschel(y1=y1, y2=y2, ngModel=ngModel)
        (fm24warm, fm24cold, fm70warm, fm70cold, fm160warm, fm160cold,
            fm24warmsmall, fm70warmsmall, fm160warmsmall
            ) = conf_s.flux_ratios_mips(y1=y1, y2=y2, ngModel=ngModel)
    elif oneBeltWander:
        (fh70warm, fh70cold, fh100warm, fh100cold, fh160warm, fh160cold,
            fh70warmsmall, fh100warmsmall, fh160warmsmall
            ) = conf_s.flux_ratios_herschel(y2=y2, ngModel=ngModel)
        (fm24warm, fm24cold, fm70warm, fm70cold, fm160warm, fm160cold,
            fm24warmsmall, fm70warmsmall, fm160warmsmall
            ) = conf_s.flux_ratios_mips(y2=y2, ngModel=ngModel)

    if showFluxRatios:
        print('--- Herschel 70 microns filter ---')
        if not oneBeltWander:
            print('f_warm/f_star : {:.2e}'.format(fh70warm))
        print('f_cold/f_star : {:.2e}'.format(fh70cold))
        if twoWarmBelts:
            print('small grains f_warm/f_star : {:.2e}'.format(fh70warmsmall))
        print('--- Herschel 100 microns filter ---')
        if not oneBeltWander:
            print('f_warm/f_star : {:.2e}'.format(fh100warm))
        print('f_cold/f_star : {:.2e}'.format(fh100cold))
        if twoWarmBelts:
            print('small grains f_warm/f_star : {:.2e}'.format(fh100warmsmall))
        print('--- Herschel 160 microns filter ---')
        if not oneBeltWander:
            print('f_warm/f_star : {:.2e}'.format(fh160warm))
        print('f_cold/f_star : {:.2e}'.format(fh160cold))
        if twoWarmBelts:
            print('small grains f_warm/f_star : {:.2e}'.format(fh160warmsmall))
        print('--- MIPS 24 microns filter ---')
        if not oneBeltWander:
            print('f_warm/f_star : {:.2e}'.format(fm24warm))
        print('f_cold/f_star : {:.2e}'.format(fm24cold))
        if twoWarmBelts:
            print('small grains f_warm/f_star : {:.2e}'.format(fm24warmsmall))
        print('--- MIPS 100 microns filter ---')
        if not oneBeltWander:
            print('f_warm/f_star : {:.2e}'.format(fm70warm))
        print('f_cold/f_star : {:.2e}'.format(fm70cold))
        if twoWarmBelts:
            print('small grains f_warm/f_star : {:.2e}'.format(fm70warmsmall))
        print('--- MIPS 160 microns filter ---')
        if not oneBeltWander:
            print('f_warm/f_star : {:.2e}'.format(fm160warm))
        print('f_cold/f_star : {:.2e}'.format(fm160cold))
        if twoWarmBelts:
            print('small grains f_warm/f_star : {:.2e}'.format(fm160warmsmall))

    # Plot realistic grain fluxes
    if not oneBeltWander:
        plt.plot(conf_s.WAVELENGTHS, y1, ls='--', color='blue',
            label=r'R$_0$ Warm: {:.2f} AU'.format(RW))
    plt.plot(conf_s.WAVELENGTHS, y2, ls='--', color='r',
        label='R$_0$ Cold: {:.2f} AU'.format(RC))
    if twoWarmBelts:
        plt.plot(conf_s.WAVELENGTHS, y3, ls='-.', color='blue',
            label=r'R$_0$ SmallGrains: {:.2f} AU'.format(RW))
    # Plot stellar model, total flux, and IRS data
    plt.plot(ngWave, n3*ngFnu, color = 'gray',
        label='Next Gen T: {} K'.format(int(starLabel)))
    plt.plot(conf_s.WAVELENGTHS, totalFlux, color='lime', label='Total Flux')
    if spitzInsts.size:
        plt.plot(spitzWaves, spitzFlux, color='black', label='Spitzer IRS')

    # Plot the rest of the real data and error bars
    # We don't want distinct labels for upper limits, so we use this list
    # of labels to check if those instruments have already been plotted.
    labeled = []
    for i in range(allWaves.size):
        inst = allInsts[i].rstrip('0123456789JHKULW')

        if 'ExoArch' in inst:
            inst = 'ExoArch'

        if inst in labeled:
            label = None
        else:
            label = inst
            labeled.append(label)
        plt.scatter(allWaves[i], allFlux[i], label=label, s=20, marker='D',
            color=plotColors[allInsts[i]], zorder=10)
        plt.errorbar(allWaves[i], allFlux[i], yerr=allError[i],
            color=plotColors[allInsts[i]])
    for i in range(ulWaves.size):
        inst = ulInsts[i].rstrip('0123456789JHKULW')
        if inst in labeled:
            label = None
        else:
            label = inst
            labeled.append(label)
        plt.scatter(ulWaves[i], ulFlux[i], label=label, s=20, marker='D',
            color=plotColors[ulInsts[i]], zorder=10)
        plt.errorbar(ulWaves[i], ulFlux[i], yerr=ulError[i], uplims=True,
            color=plotColors[ulInsts[i]])

    # Plot formatting
    plt.title(starName, fontsize=22)
    plt.xlabel(r'$\lambda$ ($\mu m$)', fontsize=18)
    plt.ylabel(r'$F_{\nu}$ ($Jy$)', fontsize=18)
    plt.semilogx()
    plt.semilogy()

    # Calculate the y limits based on the data
    if not oneBeltWander:
        if y1.max() < fitFlux[fitFlux>0].min() or \
            y2.max() < fitFlux[fitFlux>0].min():
            lowerylimit = min([y1.max(), y2.max()])*0.5
        else:
            lowerylimit = fitFlux[np.where(fitFlux>0)].min()*0.5
        if y1.max() > fitFlux.max() or y2.max() > fitFlux.max():
            upperylimit = max([y1.max(), y2.max()])*1.5
        else:
            upperylimit = fitFlux.max()*1.5
    elif oneBeltWander:
        if y2.max() < fitFlux[fitFlux>0].min():
            lowerylimit = y2.max()*0.5
        else:
            lowerylimit = fitFlux[fitFlux>0].min()*0.5
        if y2.max() > fitFlux.max():
            upperylimit = y2.max()*1.5
        else:
            upperylimit = fitFlux.max()*1.5
    plt.ylim(lowerylimit, upperylimit)

    # The x limits are standard (we only have data for certain wavelengths)
    plt.xlim(.5,300)
    plt.text(0.98, 0.98, r'Reduced $\chi^2$: {:0.1f}'.format(chiSqr),
        ha = 'right', va = 'top', transform = ax.transAxes)

    pltexts = []
    # Show the resolved radial location (if available and selected)
    if showResolved and sTrigger:
        pltexts.append(r'r$_{herschel}$: '+'({:.1f} $\pm$ {:.2f}) AU'.format(
            bbr2, bbr2_unc))
    # Show the minimum grain size
    if showMinGrain:
        if oneWander:
            pltexts.append( r'a$_{min}$: '+'{:.4f} {}m'.format(amin1, chr(956)))
        elif twoWander:
            pltexts.append(r'inner a$_{min}$: '+'{:.4f}'.format(amin1))
            pltexts.append(r'outer a$_{min}$: '+'{:.4f}'.format(amin2))
            pltexts.append('inner bos: {:.4f}'.format(bos1))
            pltexts.append('outer bos: {:.4f}'.format(bos2))
            pltexts.append(r'inner f$_{mb}$: '+'{:.4f}'.format(amin1/bos1))
            pltexts.append(r'outer f$_{mb}$: '+'{:.4f}'.format(amin2/bos2))
        elif noWander:
            pltexts.append(r'a$_{min}$: '+'{:.4f} {}m'.format(bos1, chr(956)))
        elif twoWarmBelts:
            pltexts.append(r'small a$_{min}$: '+'{:.4f} {}m'.format(amin1,
                chr(956)))
            pltexts.append(r'a$_{min}$: '+'{:.4f} {}m'.format(bos1,
                chr(956)))
        elif oneBeltWander:
            pltexts.append(r'outer a$_{min}$: '+'{:.4f}'.format(amin2))
            pltexts.append('outer bos: {:.4f}'.format(bos2))
            pltexts.append(r'outer f$_{mb}$: '+'{:.4f}'.format(amin2/bos2))

    if (showResolved and sTrigger) or showMinGrain:
        for i, pltext in enumerate(pltexts):
            plt.text(0.98, (0.92-(i*0.06)), pltext, ha = 'right', va = 'top',
                transform = ax.transAxes)

    plt.legend(loc='lower left')
    if showIRSVariance:
        ax = fig.add_subplot(212)
        indices = np.where(np.logical_and(fitWaves>= spitzWaves[0],
            fitWaves<= spitzWaves[-1]))
        variance = fitFlux - warmColdWander(fitWaves, RW, RC, amin1, amin2, n1,
            n2, n3)
        plt.plot(fitWaves[indices], variance[indices])
        plt.axhline()
    if saveResults:
        fitResults = {
            # stellar properties
            'Name': [starName], 'SpType': [specType], 'TEMP': [starT],
            'DIST_pc': [starD],

            # fitting params
            'N1': [n1], 'N2': [n2], 'N3': [n3], 'N4': [n4],
            'R_warm': [RW], 'R_cold': [RC],

            # grains properties
            'amin_warm': [amin1], 'amin_cold': [amin2],
            'bos_warm': [bos1], 'bos_cold': [bos2],
            'fmb_warm': [amin1/bos1], 'fmb_cold': [amin2/bos2],

            # dust masses
            'warm_mass': [mass_warm],
            'cold_mass': [mass_cold],
            'warm_mass_small': [small_mass_warm],

            # luminosity ratios
            'starL': [starL], 'lsld_warm': [l_warm] , 'lsld_cold': [l_cold],
            'lsld_small': [l_warm_small],

            # flux ratios
            'fh70warm': [fh70warm], 'fh70cold': [fh70cold],
            'fh100warm': [fh100warm], 'fh100cold': [fh100cold],
            'fh160warm': [fh160warm], 'fh160cold': [fh160cold],
            'fm24warm': [fm24warm], 'fm24cold': [fm24cold],
            'fm70warm': [fm70warm], 'fm70cold': [fm70cold],
            'fm160warm': [fm160warm], 'fm160cold': [fm160cold],
            }
        df = pd.DataFrame(fitResults)
        df.to_csv(PARAMS_DIR+'{}.csv'.format(starName), index=False)

    if saveFigure:
        plt.savefig(IMG_DIR+starName+'.png', bbox_inches='tight')
    if showFigure:
        plt.show()
    plt.close('all')

################################################################################
####                Run the code on the list of star names
################################################################################

if __name__ == '__main__':
    SMALL_SIZE = 8
    MEDIUM_SIZE = 12
    BIGGER_SIZE = 18
    plt.rc('font', size=MEDIUM_SIZE)          # controls default text sizes
    plt.rc('axes', titlesize=MEDIUM_SIZE)     # fontsize of the axes title
    plt.rc('axes', labelsize=BIGGER_SIZE)     # fontsize of the x and y labels
    plt.rc('xtick', labelsize=MEDIUM_SIZE)    # fontsize of the tick labels
    plt.rc('ytick', labelsize=MEDIUM_SIZE)    # fontsize of the tick labels
    plt.rc('legend', fontsize=MEDIUM_SIZE)    # legend fontsize
    plt.rc('figure', titlesize=BIGGER_SIZE)   # fontsize of the figure title

    for stn, starName in enumerate(starNames):
        # Choose the bounds on the blowout sizes given the conditional
        # statements in the options_bounds.py file.
        amin1_Low, amin1_High, amin2_Low, amin2_High = boundify(starName)

        # Let's the user know which star is running and how many are being
        # processed at a time.
        print('++++++++++++++++++++++++++++++++++++++++')
        print(' Running fit #{} of {} for star: {}'.format(stn+1,
            len(starNames), starName))
        print('++++++++++++++++++++++++++++++++++++++++')
        # Call the fitting module on the star name.
        run_fits(starName)
