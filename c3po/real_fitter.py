import os
import time
import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
from scipy.optimize import OptimizeWarning
import matplotlib.pyplot as plt
import sed_config as sconf
import temps_config as tconf
import bound_options
from common_variables import *
from fitting_options import *


# Run this code in the main loop
def run_fits(starName):
    # Reset the fitting parameters results for each star. Only the results
    # which are generated by the code will be saved, then.
    (n1, n2, n3, n4, RW, RC, amin1, amin2, bos1, bos2, small_mass_warm,
        l_warm_small) = [np.nan]*12

    # Grain compositions for each belt. Can change for different fits
    innerGrain = 'AstroSil'
    outerGrain = 'DirtyIceAstroSil'

    # Read in the star file
    starData = sconf.read_star_file(sconf.STAR_FILES+'{}_stitched.txt'.format(
    # starData = sconf.read_star_file(sconf.STAR_FILES+'{}.txt'.format(
        starName))
    starT       = starData['TEMP']    # Stellar Temperature
    starL       = starData['starL']   # Stellar Luminosity
    starMass    = starData['starM']   # Stellar Mass
    specType    = starData['SpType']  # Spectral Type
    starDist_pc = starData['DIST_pc'] # Distance to the Sun
    # Fillers for in case the data is missing.
    starL       = 1 if np.isnan(starL)       else starL
    starMass    = 1 if np.isnan(starMass)    else starMass
    starDist_pc = 1 if np.isnan(starDist_pc) else starDist_pc

    # Sort Data according to SpitzerIRS vs all else
    allSpitz, nonSpitz = sconf.sort_spitz_data(starData)
    spitzWaves = allSpitz['wavelength']
    spitzFlux  = allSpitz['flux']
    spitzError = allSpitz['error']
    spitzInsts = allSpitz['instrument']
    # Sort Data according to AllWise/AllSky vs all else
    allSky, allWise, allData = sconf.sort_wise_data(nonSpitz)

    # Load the stellar model
    ngWave, ngFnu, starLabel = sconf.load_stellar_model(starT)

    # Choose either AllWise or AllSky
    if useAllWise:
        allWaves = np.append(allData['wavelength'], allWise['wavelength'])
        allFlux = np.append(allData['flux'], allWise['flux'])
        allError = np.append(allData['error'], allWise['error'])
        allInsts = np.append(allData['instrument'], allWise['instrument'])
    elif useAllSky:
        allWaves = np.append(allData['wavelength'], allSky['wavelength'])
        allFlux = np.append(allData['flux'], allSky['flux'])
        allError = np.append(allData['error'], allSky['error'])
        allInsts = np.append(allData['instrument'], allSky['instrument'])
    else:
        allWaves = allData['wavelength']
        allFlux  = allData['flux']
        allError = allData['error']
        allInsts = allData['instrument']

    # Separate any UL data points for the fitting data points (3*sigma > signal)
    # Upper limits criterion 1
    idx      = np.where( (allFlux/allError) > 3 )
    fitWaves = allWaves[idx]
    fitFlux  = allFlux[idx]
    fitError = allError[idx]
    fitInsts = allInsts[idx]
    idx      = np.where( (allFlux/allError) <= 3 )
    ulWaves  = allWaves[idx]
    ulFlux   = allFlux[idx] + 3*allError[idx]
    ulError  = allError[idx]
    ulInsts  = allInsts[idx]
    # Remove any NaN data points (Simply missing data)
    idx      = np.isfinite(fitFlux)
    fitWaves = fitWaves[idx]
    fitFlux  = fitFlux[idx]
    fitError = fitError[idx]
    fitInsts = fitInsts[idx]
    # Remove any points with NaN for error
    # Upper Limits criterion 2
    idx      = np.isfinite(fitError)
    fitWaves = fitWaves[idx]
    fitFlux  = fitFlux[idx]
    fitError = fitError[idx]
    fitInsts = fitInsts[idx]
    idx      = np.isnan(allError)
    ulWaves  = np.append(ulWaves, allWaves[idx])
    ulFlux   = np.append(ulFlux, allFlux[idx])
    ulError  = np.append(ulError, allError[idx])
    ulInsts  = np.append(ulInsts, allInsts[idx])
    # Finally organize UL data into ascending order
    idx     = np.argsort(ulWaves)
    ulWaves = ulWaves[idx]
    ulFlux  = ulFlux[idx]
    ulError = ulError[idx]
    ulInsts = ulInsts[idx]
    # For plotting we don't want the UL data in totals
    allWaves = np.copy(fitWaves)
    allFlux  = np.copy(fitFlux)
    allError = np.copy(fitError)
    allInsts = np.copy(fitInsts)
    idx = np.argsort(allWaves)
    allWaves = allWaves[idx]
    allFlux  = allFlux[idx]
    allError = allError[idx]
    allInsts = allInsts[idx]

    # Convolve SpitzerIRS to MIPS24 frf if possible
    if 'MIPS24' in starData['instrument'] and spitzInsts.size:
        # Convolve IRS data to the MIPS24 data
        idx = np.where(starData['instrument'] == 'MIPS24')
        MIPS24W = starData['wavelength'][idx]
        MIPS24F = starData['flux'][idx]
        mipsw, mipsr = np.loadtxt(sconf.FILTERS_DIR + 'mips24_frf.txt',
            unpack=True)
        IRS24      = sconf.convolve(mipsw, mipsr, spitzWaves, spitzFlux)
        spitzFlux *= (MIPS24F/IRS24)
        fitWaves   = np.append(fitWaves, spitzWaves)
        fitFlux    = np.append(fitFlux, spitzFlux)
        fitError   = np.append(fitError, spitzError)
    # Else, just add the spitzer data to fit data
    elif spitzInsts.size:
        fitWaves  = np.append(fitWaves, spitzWaves)
        fitFlux   = np.append(fitFlux, spitzFlux)
        fitError  = np.append(fitError, spitzError)

    # Organize all data by increasing wavelength.
    idx = np.argsort(fitWaves)
    fitWaves = fitWaves[idx]
    fitFlux  = fitFlux[idx]
    fitError = fitError[idx]

    # Normalize stellar model from either SL2 or 2MASSK data.
    if 'SpitzerIRS-SL2' in spitzInsts:
        idx          = np.where(np.logical_and(fitWaves>5, fitWaves<5.5))
        dataFluxNorm = np.nanmean(fitFlux[idx])
        ngFluxNorm   = np.nanmean(np.interp(fitWaves[idx], ngWave, ngFnu))
        n_3          = (dataFluxNorm/ngFluxNorm)
        ngFnu       *= n_3
    elif '2MASSK' in allInsts:
        idx          = np.where(starData['instrument'] == '2MASSK')
        dataFluxNorm = starData[fx][idx]
        ngFluxNorm   = np.nanmean(np.interp(starData[wa][idx], ngWave, ngFnu))
        n_3          = (dataFluxNorm/ngFluxNorm)
        ngFnu       *= n_3

    # Calculate luminosity of the star given the stellar model and star distance
    luminosity = sconf.calc_luminosity(ngWave, ngFnu, starDist_pc)
    print( "Calculated luminosity: {:0.3f}".format(luminosity) )
    print( "Given luminosity: {:0.3f}".format(starL) )
    # grain temps calculator depends on having accurate luminosities
    starL = luminosity if (starL == 1) else starL

    # Interpolate the stellar model to the fitting data wavelengths
    ngFnu_fit = np.e**np.interp(np.log(fitWaves), np.log(ngWave), np.log(ngFnu))

    # Create the star objects
    # Calculate blowoutsize given grain density
    bos1 = sconf.blowout_size(densities[innerGrain], starL, starMass)
    bos2 = sconf.blowout_size(densities[outerGrain], starL, starMass)
    bos1 *= bosScalar1
    bos2 *= bosScalar2

    # Index of grains greater than the blowout size
    graindex1 = sconf.find_nearest_ind(sconf.GRAINSIZES, bos1)
    graindex2 = sconf.find_nearest_ind(sconf.GRAINSIZES, bos2)

    # Load the grain temperatures, or calculate them
    grainTemps = dict()
    for grainComp in grainComps:
        try:
            grainTemps[grainComp] = np.load(
                sconf.GRAIN_TEMPS_DIR+"{}_{}.npy".format(starName, grainComp))
        except:
            grainTemps[grainComp] = tconf.calc_temps(starT, starL, grainComp)
            np.save(
                sconf.GRAIN_TEMPS_DIR+"{}_{}.npy".format(starName, grainComp),
                grainTemps[grainComp], allow_pickle=False
                )

    # hi res emissivities star object
    star2 = sconf.Star(starDist_pc, starL, starT, grainTemps, bos1, bos2,
        sconf.EMISSIVITIES_TOTAL, sconf.GRAINSIZES, graindex1, graindex2)

    # Grab the minimum radial location that's below the temp
    # of sublimation for volatiles. (Icy belt radius)
    for r in range(1000):
        # If mean temp < 120, then that becomes the min radius
        if np.nanmean(grainTemps[outerGrain][r]) < 120:
            break
    minRad = np.logspace(-1, 3, 1000)[r]

    print( '----------------------------------------' )
    print( '      AS blowout size: {:.2f}'.format(bos1) )
    print( '     IMP blowout size: {:.2f}'.format(bos2) )
    print( ' Minimum radius for an icy belt: {:.2f}'.format(minRad) )

    # Warm r0 guess is half the distance between the cold belt min & the star
    bbr1 = minRad*0.5
    # Cold belt guess is either from spatially resolved radii or 1.5*minRad
    if useSpatialRadii:
        rData = pd.read_csv('./Data/spatialRadii.csv', index_col=False)
        for i in range(len(rData)):
            if starName in [ rData.at[i, 'name'], rData.at[i, 'hip_name'] ]:
                bbr2     = rData.at[i, 'r']
                bbr2_unc = rData.at[i, 'r_sig']
                try:
                    if 3*bbr2_unc > bbr2 or np.isnan(bbr2):
                        raise ValueError("No valid radius from Herschel")
                    sTrigger = 1
                except:
                    bbr2 = minRad*1.5
                    sTrigger = 0
                break
        else:
            bbr2 = minRad*1.5
            sTrigger = 0
    else:
        bbr2 = minRad*1.5
        sTrigger = 0

    if bbr2 > 1000:
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        print("The initial guess for the cold belt {} is greater".format(bbr2))
        print("than the highest possible value of 1000. Continuing with next")
        print("star. In future, we may expand radial locations?")
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        return

    print( "initial guess for RW: {:.2f}".format(bbr1) )
    print( "initial guess for RC: {:.2f}".format(bbr2) )

    # Interp emissivities to fitWaves
    emis = {}
    emis[innerGrain] = np.empty((sconf.GRAINSIZES.size, fitWaves.size))
    for g in range(sconf.GRAINSIZES.size):
        emis[innerGrain][g] = np.interp(fitWaves, sconf.WAVELENGTHS,
            sconf.EMISSIVITIES_TOTAL[innerGrain][g])
    emis[outerGrain] = np.empty((sconf.GRAINSIZES.size, fitWaves.size))
    for g in range(sconf.GRAINSIZES.size):
        emis[outerGrain][g] = np.interp(fitWaves, sconf.WAVELENGTHS,
            sconf.EMISSIVITIES_TOTAL[outerGrain][g])
    # Low res emissivities star object
    star1 = sconf.Star(starDist_pc, starL, starT, grainTemps, bos1, bos2,
        emis, sconf.GRAINSIZES, graindex1, graindex2)

    # Normalize warm and cold dust
    if oneWander:
        bb1 = star1.calcFluxBoSWarm(fitWaves, bbr1, bos1)
        bb2 = star1.calcFluxCold(fitWaves, bbr2)
    elif twoWander:
        bb1 = star1.calcFluxBoSWarm(fitWaves, bbr1, bos1)
        bb2 = star1.calcFluxBoSCold(fitWaves, bbr2, bos2)
    elif noWander:
        bb1 = star1.calcFluxWarm(fitWaves, bbr1)
        bb2 = star1.calcFluxCold(fitWaves, bbr2)
    elif twoWarmBelts:
        bb1 = star1.calcFluxWarm(fitWaves, bbr1)
        bb2 = star1.calcFluxCold(fitWaves, bbr2)
    # warm
    n_1 = fitFlux[np.where(fitFlux>0)].min() / bb1.max() # new test
    # cold
    n_2 = fitFlux[-3:].max() / bb2.max()
    # Reset norm factor for ngfNu
    n_3 = 1

    if showNormedBelts:
        # Show the normalized belts with observed flux and stellar model
        fig = plt.figure(figsize=(8, 6))
        plt.plot(ngWave, ngFnu, label='Stellar Model', color='g')
        plt.plot(fitWaves, n_1*bb1, label='Warm Belt')
        plt.plot(fitWaves, n_2*bb2, label='Cold Belt')
        plt.scatter(fitWaves, fitFlux, label='Observed Data')
        plt.xlim(1, 300)
        plt.ylim(n_1*bb1.max()*0.1, n_2*bb2.max()*100 )
        plt.title(starName+': for seeing the normalized belts', fontsize=22)
        plt.legend()
        plt.xlabel(r'$\lambda$ ($\mu m$)')
        plt.ylabel(r'$F_{\nu}$ ($Jy$)')
        plt.semilogx()
        plt.semilogy()
        plt.show()
        return

    # Fitting functions for optimization routine
    # option: noWander
    def warmCold(waves, r0warm, r0cold, n1, n2, n3):
        ''' Standard realistic grain fit: one warm belt, one cold belt '''
        return n1*star1.calcFluxWarm(waves, r0warm) \
            + n2*star1.calcFluxCold(waves, r0cold) + n3*ngFnu_fit
    # option: oneWander
    def oneWarmWander(waves, r0warm, r0cold, amin1, n1, n2, n3):
        ''' one warm belt with a wandering blowout grain size, one cold belt '''
        return n1*star1.calcFluxBoSWarm(waves, r0warm, amin1) \
            + n2*star1.calcFluxCold(waves, r0cold) + n3*ngFnu_fit
    # option: twoWander
    def warmColdWander(waves, r0warm, r0cold, amin1, amin2, n1, n2, n3):
        ''' one warm belt with a wandering blowout grain size,
        one cold belt with a wandering blowout grain size'''
        return n1*star1.calcFluxBoSWarm(waves, r0warm, amin1) \
            + n2*star1.calcFluxBoSCold(waves, r0cold, amin2) + n3*ngFnu_fit
    # option: twoWarmBelts
    def twoWarmCold(waves, r0warm, r0cold, amin1, n1, n2, n3, n4):
        return n1*star1.calcFluxWarm(waves, r0warm) \
            + n2*star1.calcFluxCold(waves, r0cold) + n3*ngFnu_fit \
            + n4*star1.calcFluxWarmMinGrains(waves, r0warm, amin1)

    # Run the optimization routine
    print("----------------------------------------")
    print( "      Begin Optimizing Parameters" )
    print("----------------------------------------")
    rw = bbr1
    rc = bbr2
    # Set initial guess for the blowout size. If the bounded region includes the
    # calculated blowout size, use that, else go in between the bounds.
    if  bosHighInner < 1 or 1./bosLowInner > 1:
        p0amin1 = bos1*np.average([bosHighInner, 1./bosLowInner])
    else:
        p0amin1 = bos1
    if  bosHighOuter < 1 or 1./bosLowOuter > 1:
        p0amin2 = bos2*np.average([bosHighOuter, 1./bosLowOuter])
    else:
        p0amin2 = bos2
    if oneWander:
        # parameters: r0warm, r0cold, amin1, n1, n2, n3
        if useSpatialRadii and sTrigger:
            lBounds = [0.3, bbr2-bbr2_unc, 1e-3,
                    n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, bbr2+bbr2_unc, bosHighInner*bos1,
                    n_1*beltBound, n_2*beltBound, n_3*1.2]
        else:
            lBounds = [0.3, minRad, 1e-3, n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, maxRad, bosHighInner*bos1,
                n_1*beltBound, n_2*beltBound, n_3*1.2]
        p0=(rw, rc, p0amin1, n_1, n_2, n_3)
    elif twoWander:
        # parameters: r0warm, r0cold, amin1, amin2, n1, n2, n3
        if useSpatialRadii and sTrigger:
            lBounds = [0.3, bbr2 - bbr2_unc, bos1/bosLowInner,
                bos2/bosLowOuter, n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, bbr2 + bbr2_unc, bos1*bosHighInner,
                bos2*bosHighOuter, n_1*beltBound, n_2*beltBound, n_3*1.2]
        else:
            lBounds = [0.3, minRad, bos1/bosLowInner, bos2/bosLowOuter,
                    n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, maxRad, bos1*bosHighInner, bos2*bosHighOuter,
                    n_1*beltBound, n_2*beltBound, n_3*1.2]
        p0=(rw, rc, p0amin1, p0amin2, n_1, n_2, n_3)
    elif noWander:
        # parameters: r0warm, r0cold, n1, n2, n3
        if useSpatialRadii and sTrigger:
            lBounds = [0.3, bbr2-bbr2_unc, n_1/beltBound, n_2/beltBound,
                n_3*0.8]
            uBounds = [minRad, bbr2+bbr2_unc, n_1*beltBound, n_2*beltBound,
                n_3*1.2]
        else:
            lBounds = [0.3, minRad, n_1/beltBound, n_2/beltBound, n_3*0.8]
            uBounds = [minRad, maxRad, n_1*beltBound, n_2*beltBound, n_3*1.2]
        p0=(rw, rc, n_1, n_2, n_3)
    elif twoWarmBelts:
        # params: r0warm, r0cold, amin1, n1, n2, n3, n4
        if useSpatialRadii and sTrigger:
            lBounds = [0.3, bbr2-bbr2_unc, 0.01, n_1/beltBound, n_2/beltBound,
                n_3*0.8, n_1/beltBound]
            uBounds = [minRad, bbr2+bbr2_unc, bos1, n_1*beltBound,
                n_2*beltBound, n_3*1.2, n_1*beltBound]
        else:
            lBounds = [0.3, minRad, 0.01, n_1/beltBound, n_2/beltBound,
                n_3*0.8, n_1/beltBound]
            uBounds = [minRad, 500, bos1, n_1*beltBound, n_2*beltBound,
                n_3*1.2, n_1*beltBound]
        p0=(rw, rc, bos1/2, n_1, n_2, n_3, n_1)
    bounds=[lBounds, uBounds]

    # Timer for the routine
    before = time.perf_counter()
    # Call the optimization routine here.
    try:
        if oneWander:
            popt, pcov = curve_fit(oneWarmWander, fitWaves, fitFlux,
                sigma=fitError, p0=p0, bounds=bounds)
        elif twoWander:
            popt, pcov = curve_fit(warmColdWander, fitWaves, fitFlux,
                sigma=fitError, p0=p0, bounds=bounds)
        elif noWander:
            popt, pcov = curve_fit(warmCold, fitWaves, fitFlux, sigma=fitError,
                p0=p0, bounds=bounds)
        elif twoWarmBelts:
            popt, pcov = curve_fit(twoWarmCold, fitWaves, fitFlux,
                sigma=fitError, p0=p0, bounds=bounds)
    except RuntimeError:
        print("RuntimeError: The least squares minimization failed.")
        print("Continuing with next star")
        return
    except ValueError:
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        print("ValueError: Either xdata or ydata contains NaN")
        print("Check flux sigma for nan values.")
        print("Use those points as UL data instead.")
        print("Continuing with next star")
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        return
    except OptimizeWarning:
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        print("The covariance of the parameters cannot be estimated")
        print("Continuing with next star")
        print("!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!")
        return
    # Timer for the fitting routine
    after = time.perf_counter()
    # Unpack the parameters and print them to the terminal for the user
    if oneWander:
        RW, RC, amin1, n1, n2, n3 = popt
    elif twoWander:
        RW, RC, amin1, amin2, n1, n2, n3 = popt
    elif noWander:
        RW, RC, n1, n2, n3 = popt
    elif twoWarmBelts:
        RW, RC, amin1, n1, n2, n3, n4 = popt
    print( '  Time to optimize parameters: {:.2f}s'.format(after-before) )
    print( '        Warm radius: {:.2f}'.format(RW) )
    print( '        Cold radius: {:.2f}'.format(RC) )
    print( '          Warm norm: {:.2e}'.format(n1) )
    print( '          Cold norm: {:.2e}'.format(n2) )
    print( '       Stellar norm: {:.2f}'.format(n3) )
    if oneWander:
        print( ' Warm min grainsize: {:.2f}'.format(amin1) )
    elif twoWander:
        print( ' Warm min grainsize: {:.2f}'.format(amin1))
        print( ' Cold min grainsize: {:.2f}'.format(amin2))
    elif noWander:
        pass
    elif twoWarmBelts:
        print( '  Minimum Grainsize: {:.2f}'.format(amin1) )
    print( '----------------------------------------' )

    # Calculate reduced chi square value
    if oneWander:
        resid = fitFlux-oneWarmWander(fitWaves, RW, RC, amin1, n1, n2, n3)
        degsFreedom = fitWaves.size - 6
    elif twoWander:
        resid = fitFlux-warmColdWander(fitWaves, RW, RC, amin1, amin2, n1, n2, n3)
        degsFreedom = fitWaves.size - 7
    elif noWander:
        resid = fitFlux-warmCold(fitWaves, RW, RC, n1, n2, n3)
        degsFreedom = fitWaves.size - 5
    elif twoWarmBelts:
        resid = fitFlux-twoWarmCold(fitWaves, RW, RC, amin1, n1, n2, n3, n4)
        degsFreedom = fitWaves.size - 7
    resid /= fitError
    chiSqr = np.dot(resid, resid)/degsFreedom # Reduced chi square

    # Begin plotting routine
    if showIRSVariance:
        # Create a figure with two plots, one for the model + data, one for the
        # IRS variance
        fig = plt.figure(figsize=(8, 10))
        ax = fig.add_subplot(211)
    else:
        # Otherwise just create a figure with a single plot for the model + data
        fig = plt.figure(figsize=(8, 6))
        ax = fig.add_subplot(111)
    SMALL_SIZE = 8
    MEDIUM_SIZE = 12
    BIGGER_SIZE = 18
    plt.rc('font', size=MEDIUM_SIZE)          # controls default text sizes
    plt.rc('axes', titlesize=MEDIUM_SIZE)     # fontsize of the axes title
    plt.rc('axes', labelsize=BIGGER_SIZE)     # fontsize of the x and y labels
    plt.rc('xtick', labelsize=MEDIUM_SIZE)    # fontsize of the tick labels
    plt.rc('ytick', labelsize=MEDIUM_SIZE)    # fontsize of the tick labels
    plt.rc('legend', fontsize=MEDIUM_SIZE)    # legend fontsize
    plt.rc('figure', titlesize=BIGGER_SIZE)   # fontsize of the figure title

    # Calculate the high resolution totalFlux array given the optimized
    # parameters
    if oneWander:
        y1 = n1 * star2.calcFluxBoSWarm(sconf.WAVELENGTHS, RW, amin1)
        y2 = n2 * star2.calcFluxCold(sconf.WAVELENGTHS, RC)
        ngModel = np.e**np.interp(np.log(sconf.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y1 + y2 + ngModel
    elif twoWander:
        y1 = n1 * star2.calcFluxBoSWarm(sconf.WAVELENGTHS, RW, amin1)
        y2 = n2 * star2.calcFluxBoSCold(sconf.WAVELENGTHS, RC, amin2)
        ngModel = np.e**np.interp(np.log(sconf.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y1 + y2 + ngModel
    elif noWander:
        y1 = n1 * star2.calcFluxWarm(sconf.WAVELENGTHS, RW)
        y2 = n2 * star2.calcFluxCold(sconf.WAVELENGTHS, RC)
        ngModel = np.e**np.interp(np.log(sconf.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y1 + y2 + ngModel
    elif twoWarmBelts:
        y1 = n1 * star2.calcFluxWarm(sconf.WAVELENGTHS, RW)
        y2 = n2 * star2.calcFluxCold(sconf.WAVELENGTHS, RC)
        y3 = n4 * star2.calcFluxBoSWarm(sconf.WAVELENGTHS, RW, amin1)
        ngModel = np.e**np.interp(np.log(sconf.WAVELENGTHS), np.log(ngWave),
            np.log(n3*ngFnu))
        totalFlux = y1 + y2 + y3 + ngModel

    # Calculate Lstar/Ldust
    l_warm = sconf.lum_ratio(ngModel, y1, sconf.WAVELENGTHS)
    l_cold = sconf.lum_ratio(ngModel, y2, sconf.WAVELENGTHS)
    if twoWarmBelts:
        l_warm_small = sconf.lum_ratio(ngModel, y3, sconf.WAVELENGTHS)

    # Calculate dust mass of each belt in lunar masses
    if oneWander:
        mass_warm = star2.calcDustMass(n1, RW, amin1*1e-6, 1e-3,
            densities[innerGrain])/moon_mass
        mass_cold = star2.calcDustMass(n1, RC, bos2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
    elif twoWander:
        mass_warm = star2.calcDustMass(n1, RW, amin1*1e-6, 1e-3,
            densities[innerGrain])/moon_mass
        mass_cold = star2.calcDustMass(n1, RC, amin2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
    elif noWander:
        mass_warm = star2.calcDustMass(n1, RC, bos1*1e-6, 1e-3,
            densities[innerGrain])/moon_mass
        mass_cold = star2.calcDustMass(n1, RC, bos2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
    elif twoWarmBelts:
        mass_warm = star2.calcDustMass(n1, RW, bos1*1e-6, 1e-3,
            densities[innerGrain])/moon_mass
        mass_cold = star2.calcDustMass(n1, RC, bos2*1e-6, 1e-3,
            densities[outerGrain])/moon_mass
        small_mass_warm = star2.calcDustMass(n1, RW, amin1*1e-6,
            bos1*1e-6, densities[innerGrain])/moon_mass
    if showDustMass:
        print("Warm dust mass: {:.2e} lunar masses".format(
            mass_warm))
        print("Cold dust mass: {:.2e} lunar masses".format(
            mass_cold))
        if twoWarmBelts:
            print("Warm small grain dust mass: {:.2e} lunar masses".format(
                small_mass_warm))

    if showLumRatios:
        print("Ldust_warm/Lstar: {:.2e}".format(l_warm))
        print("Ldust_cold/Lstar: {:.2e}".format(l_cold))
        if twoWarmBelts:
            print("Ldust_warm_small_grains/Lstar: {:.2e}".format(l_warm_small))

    # Calculate the flux ratios
    if twoWarmBelts:
        (fh70warm, fh70cold, fh100warm, fh100cold, fh160warm, fh160cold,
            fh70warmsmall, fh100warmsmall, fh160warmsmall
            ) = sconf.flux_ratios_herschel(y1, y2, ngModel, y3)
        (fm24warm, fm24cold, fm70warm, fm70cold, fm160warm, fm160cold,
            fm24warmsmall, fm70warmsmall, fm160warmsmall
            ) = sconf.flux_ratios_mips(y1, y2, ngModel, y3)

    else:
        (fh70warm, fh70cold, fh100warm, fh100cold, fh160warm, fh160cold,
            fh70warmsmall, fh100warmsmall, fh160warmsmall
            ) = sconf.flux_ratios_herschel(y1, y2, ngModel)
        (fm24warm, fm24cold, fm70warm, fm70cold, fm160warm, fm160cold,
            fm24warmsmall, fm70warmsmall, fm160warmsmall
            ) = sconf.flux_ratios_mips(y1, y2, ngModel)
    if showFluxRatios:
        print("--- Herschel 70 microns filter ---")
        print("f_warm/f_star : {:.2e}".format(fh70warm))
        print("f_cold/f_star : {:.2e}".format(fh70cold))
        if twoWarmBelts:
            print("small grains f_warm/f_star : {:.2e}".format(fh70warmsmall))
        print("--- Herschel 100 microns filter ---")
        print("f_warm/f_star : {:.2e}".format(fh100warm))
        print("f_cold/f_star : {:.2e}".format(fh100cold))
        if twoWarmBelts:
            print("small grains f_warm/f_star : {:.2e}".format(fh100warmsmall))
        print("--- Herschel 160 microns filter ---")
        print("f_warm/f_star : {:.2e}".format(fh160warm))
        print("f_cold/f_star : {:.2e}".format(fh160cold))
        if twoWarmBelts:
            print("small grains f_warm/f_star : {:.2e}".format(fh160warmsmall))
        print("--- MIPS 24 microns filter ---")
        print("f_warm/f_star : {:.2e}".format(fm24warm))
        print("f_cold/f_star : {:.2e}".format(fm24cold))
        if twoWarmBelts:
            print("small grains f_warm/f_star : {:.2e}".format(fm24warmsmall))
        print("--- MIPS 100 microns filter ---")
        print("f_warm/f_star : {:.2e}".format(fm70warm))
        print("f_cold/f_star : {:.2e}".format(fm70cold))
        if twoWarmBelts:
            print("small grains f_warm/f_star : {:.2e}".format(fm70warmsmall))
        print("--- MIPS 160 microns filter ---")
        print("f_warm/f_star : {:.2e}".format(fm160warm))
        print("f_cold/f_star : {:.2e}".format(fm160cold))
        if twoWarmBelts:
            print("small grains f_warm/f_star : {:.2e}".format(fm160warmsmall))

    # Plot realistic grain fluxes
    plt.plot(sconf.WAVELENGTHS, y1, ls='--', color='blue',
        label=r'R$_0$ Warm: {:.2f} AU'.format(RW))
    plt.plot(sconf.WAVELENGTHS, y2, ls='--', color='r',
        label='R$_0$ Cold: {:.2f} AU'.format(RC))
    if twoWarmBelts:
        plt.plot(sconf.WAVELENGTHS, y3, ls='-.', color='blue',
            label=r'R$_0$ SmallGrains: {:.2f} AU'.format(RW))
    # Plot stellar model, total flux, and IRS data
    plt.plot(ngWave, n3*ngFnu, color = 'gray',
        label='Next Gen T: {} K'.format(int(starLabel)))
    plt.plot(sconf.WAVELENGTHS, totalFlux, color='lime', label='Total Flux')
    if spitzInsts.size:
        plt.plot(spitzWaves, spitzFlux, color='black', label='Spitzer IRS')

    # Plot the rest of the real data and error bars
    # We don't want distinct labels for upper limits, so we use this list
    # of labels to check if those instruments have already been plotted.
    labeled = []
    for i in range(allWaves.size):
        inst = allInsts[i].rstrip('0123456789JHKULW')
        if inst in labeled:
            label = None
        else:
            label = inst
            labeled.append(label)
        plt.scatter(allWaves[i], allFlux[i], label=label, s=20, marker='D',
            color=plotColors[allInsts[i]], zorder=10)
        plt.errorbar(allWaves[i], allFlux[i], yerr=allError[i],
            color=plotColors[allInsts[i]])
    for i in range(ulWaves.size):
        inst = ulInsts[i].rstrip('0123456789JHKULW')
        if inst in labeled:
            label = None
        else:
            label = inst
            labeled.append(label)
        plt.scatter(ulWaves[i], ulFlux[i], label=label, s=20, marker='D',
            color=plotColors[ulInsts[i]], zorder=10)
        plt.errorbar(ulWaves[i], ulFlux[i], yerr=ulError[i], uplims=True,
            color=plotColors[ulInsts[i]])

    # Plot formatting
    plt.title(starName, fontsize=22)
    plt.xlabel(r'$\lambda$ ($\mu m$)')
    plt.ylabel(r'$F_{\nu}$ ($Jy$)')
    plt.semilogx()
    plt.semilogy()
    # Calculate the y limits based on the data
    if y1.max() < fitFlux[np.where(fitFlux>0)].min() or \
        y2.max() < fitFlux[np.where(fitFlux>0)].min():
        lowerylimit = min([y1.max(), y2.max()])*0.5
    else:
        lowerylimit = fitFlux[np.where(fitFlux>0)].min()*0.5

    if y1.max() > fitFlux.max() or y2.max() > fitFlux.max():
        upperylimit = max([y1.max(), y2.max()])*1.5
    else:
        upperylimit = fitFlux.max()*1.5
    plt.ylim(lowerylimit, upperylimit)

    # The x limits are standard (we only have data for certain wavelengths)
    plt.xlim(.5,300)
    plt.text(0.98, 0.98, r"Reduced $\chi^2$: {:0.1f}".format(chiSqr),
        ha = 'right', va = 'top', transform = ax.transAxes)

    pltexts = []
    # Show the resolved radial location (if available and selected)
    if showResolved and sTrigger:
        pltexts.append(r"r$_{herschel}$: "+"({:.1f} $\pm$ {:.2f}) AU".format(
            bbr2, bbr2_unc))
    # Show the minimum grain size
    if showMinGrain:
        if oneWander:
            pltexts.append( r"a$_{min}$: "+"{:.4f} {}m".format(amin1, chr(956)))
        elif twoWander:
            pltexts.append(r"inner a$_{min}$: "+"{:.4f}".format(amin1))
            pltexts.append(r"outer a$_{min}$: "+"{:.4f}".format(amin2))
            pltexts.append("inner bos: {:.4f}".format(bos1))
            pltexts.append("outer bos: {:.4f}".format(bos2))
            pltexts.append(r"inner f$_{mb}$: "+"{:.4f}".format(amin1/bos1))
            pltexts.append(r"outer f$_{mb}$: "+"{:.4f}".format(amin2/bos2))
        elif noWander:
            pltexts.append(r"a$_{min}$: "+"{:.4f} {}m".format(bos1, chr(956)))
        elif twoWarmBelts:
            pltexts.append(r"small a$_{min}$: "+"{:.4f} {}m".format(amin1,
                chr(956)))
            pltexts.append(r"a$_{min}$: "+"{:.4f} {}m".format(bos1,
                chr(956)))
    if (showResolved and sTrigger) or showMinGrain:
        for i, pltext in enumerate(pltexts):
            plt.text(0.98, (0.92-(i*0.06)), pltext, ha = 'right', va = 'top',
                transform = ax.transAxes)

    plt.legend(loc='lower left')
    if showIRSVariance:
        ax = fig.add_subplot(212)
        indices = np.where(np.logical_and(fitWaves>= spitzWaves[0],
            fitWaves<= spitzWaves[-1]))
        variance = fitFlux - warmColdWander(fitWaves, RW, RC, amin1, amin2, n1,
            n2, n3)
        plt.plot(fitWaves[indices], variance[indices])
        plt.axhline()
    if saveResults:
        fitResults = {
            # stellar properties
            'Name': [starName],
            # fitting params
            'N1': [n1], 'N2': [n2], 'N3': [n3], 'N4': [n4],
            'R_warm': [RW], 'R_cold': [RC],

            # grains properties
            'amin_warm': [amin1], 'amin_cold': [amin2],
            'bos_warm': [bos1], 'bos_cold': [bos2],
            'fmb_warm': [amin1/bos1], 'fmb_cold': [amin2/bos2],

            # dust masses
            'warm_mass': [mass_warm],
            'cold_mass': [mass_cold],
            'warm_mass_small': [small_mass_warm],

            # luminosity ratios
            'starL': [starL], 'lsld_warm': [l_warm] , 'lsld_cold': [l_cold],
            'lsld_small': [l_warm_small],
            }
        fluxRatioResults = {
            # flux ratios
            'fh70warm': [fh70warm], 'fh70cold': [fh70cold],
            'fh100warm': [fh100warm], 'fh100cold': [fh100cold],
            'fh160warm': [fh160warm], 'fh160cold': [fh160cold],
            'fm24warm': [fm24warm], 'fm24cold': [fm24cold],
            'fm70warm': [fm70warm], 'fm70cold': [fm70cold],
            'fm160warm': [fm160warm], 'fm160cold': [fm160cold],
            }
        df = pd.DataFrame(fitResults)
        df.to_csv(PARAMS_DIR+'{}.csv'.format(starName), index=False)
        df = pd.DataFrame(fluxRatioResults)
        df.to_csv(FRATIOS_DIR+'{}.csv'.format(starName), index=False)

    if saveFigure:
        plt.savefig(IMG_DIR+starName+'.png', bbox_inches='tight')
    if showFigure:
        plt.show()
    plt.close('all')

################################################################################
####                Run the code on the list of star names
################################################################################

if __name__ == '__main__':

    # starNames = starNames[7:]
    for stn, starName in enumerate(starNames):
        # Choose the bounds on the blowout sizes given the conditional
        # statements in the bound_options.py file.
        bosLowInner, bosHighInner, bosLowOuter, bosHighOuter = (
            bound_options.boundify(starName)
            )

        # Let's the user know which star is running and how many are being
        # processed at a time.
        print("++++++++++++++++++++++++++++++++++++++++")
        print(" Running fit #{} of {} for star: {}".format(stn+1,
            len(starNames), starName))
        print("++++++++++++++++++++++++++++++++++++++++")
        # Call the fitting module on the star name.
        run_fits(starName)
